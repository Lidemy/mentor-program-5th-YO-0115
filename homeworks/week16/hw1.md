# week16 hw1
下列程式碼會輸出什麼 ?
``` js
console.log(1)
setTimeout(() => {
  console.log(2)
}, 0)
console.log(3)
setTimeout(() => {
  console.log(4)
}, 0)
console.log(5)
```
輸出順序 : 1 -> 3 -> 5 -> 2 -> 4

那這又是為甚麼呢 ? 

JS 引擎解析程式碼是一行一行的向下解析，但是這樣的機制會有一些問題，假設第二行的 setTimeout 設的秒數是 10 秒，那依照上述邏輯來說，整段程式碼就會卡在那裡 10 秒才會繼續向下執行，或許你會覺得這沒什麼，但如果把這個行為放在瀏覽器上，當使用者點擊一個物件時，整個頁面就不能操作，直到 10 秒過去，這樣的使用者體驗就會非常之差。

所以他背後的實作原理可以大致分成三個區塊：JS 引擎、瀏覽器、待執行區 

JS 引擎
1. 解析執行 console.log(1)
2. 解析 setTimeout 發現是 callback function，將他丟給瀏覽器，讓他幫忙做事
3. 解析執行 console.log(3)
4. 解析 setTimeout 發現是 callback function，將他丟給瀏覽器，讓他幫忙做事
5. 解析執行 console.log(5)
6. 程式碼全部跑完了，就去看看待執行區有沒有任務要執行
7. 執行 console.log(2)
8. 執行 console.log(5)

瀏覽器
1. 接收 setTimeout 並幫忙處理
2. 得到結果後，把 setTimeout 這個任務丟到待執行區

待執行區
1. 接收從瀏覽器丟過來的任務
2. 觀察 JS 引擎，一但 JS 引擎自身的任務全部結束，就將堆積的在本區的任務，一項一項的丟回 JS 引擎，讓他執行最後的結果

### 總結
就 setTimeout 來說，它只能保證至少會在它設定的時間之後才會執行，但是否會在設定時間一到就馬上出現，這就不一定了，因為就算設置 0 秒，JS 引擎也不會優先處理它，而是會把它先丟給瀏覽器代為處理。
